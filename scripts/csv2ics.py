# csv2ics.py

import csv
import os
import re
import argparse
import sys
import traceback
from collections import defaultdict
from datetime import datetime
from ics import Calendar, Event
from ics.grammar.parse import ContentLine
from utils import validate_csv_path, ensure_output_dir

COMMON_FORMATS = [
    "%Y-%m-%d %H:%M",
    "%m/%d/%Y %H:%M",
    "%m/%d/%Y %I:%M %p",
    "%Y-%m-%d %I:%M %p",
    "%d-%m-%Y %H:%M",
    "%d/%m/%Y %H:%M",
]

def find_column(columns, patterns):
    for pattern in patterns:
        regex = re.compile(pattern, re.IGNORECASE)
        for col in columns:
            if regex.match(col.strip()):
                return col
    return None

def parse_datetime(row, columns):
    start_dt_col = find_column(columns, ["^Start Date[- ]?Time$", "^Start.*Date.*Time$"])
    end_dt_col = find_column(columns, ["^End Date[- ]?Time$", "^End.*Date.*Time$"])

    if start_dt_col and end_dt_col:
        start = row[start_dt_col]
        end = row[end_dt_col]
    else:
        date_col = find_column(columns, ["^Date$"])
        start_date_col = find_column(columns, ["^Start Date$", "^Date$"])
        start_time_col = find_column(columns, ["^Start Time$", "^Start.*Time$"])
        end_date_col = find_column(columns, ["^End Date$", "^Date$"])
        end_time_col = find_column(columns, ["^End Time$", "^End.*Time$"])

        start_date = row.get(start_date_col) or row.get(date_col)
        start_time = row.get(start_time_col, "00:00")
        end_date = row.get(end_date_col) or row.get(date_col)
        end_time = row.get(end_time_col, "01:00")

        start = f"{start_date} {start_time}"
        end = f"{end_date} {end_time}"

    return start.strip(), end.strip()

def detect_datetime_format(samples):
    for fmt in COMMON_FORMATS:
        try:
            for start, end in samples:
                datetime.strptime(start, fmt)
                datetime.strptime(end, fmt)
            return fmt
        except ValueError:
            continue
    return None

def read_events(csv_file):
    events_by_team = defaultdict(list)
    samples = []
    with open(csv_file, newline='', encoding="utf-8-sig") as f:
        reader = csv.DictReader(f)
        columns = reader.fieldnames

        team_col = find_column(columns, ["^Team$"])
        title_col = find_column(columns, ["^Event Title$", "^Title$"])
        desc_col = find_column(columns, ["^Description$"])
        location_col = find_column(columns, ["^Location$"])

        for i, row in enumerate(reader):
            team = row.get(team_col, "General")
            start, end = parse_datetime(row, columns)

            if i < 5:
                samples.append((start, end))

            title = row.get(title_col) or row.get(desc_col) or "Untitled Event"
            description = row.get(desc_col) or row.get(title_col) or ""

            event = {
                "title": title,
                "start": start,
                "end": end,
                "location": row.get(location_col, ""),
                "description": description
            }
            events_by_team[team].append(event)
    return events_by_team, samples

def create_ics_old(team, events, output_dir, datetime_format):
    cal = Calendar()
    
    # âœ… Use ContentLine for metadata
    cal.extra.append(ContentLine(name="X-WR-CALNAME", value=team))
    cal.extra.append(ContentLine(name="NAME", value=team))
    cal.extra.append(ContentLine(name="X-WR-CALDESC", value="Generated by Mark Hogan's Calendar Builder"))

    for e in events:
        try:
            event = Event()
            event.name = e["title"]
            event.begin = datetime.strptime(e["start"], datetime_format)
            event.end = datetime.strptime(e["end"], datetime_format)
            event.location = e["location"]
            event.description = e["description"]
            cal.events.add(event)
        except ValueError as ve:
            print(f"âŒ Error parsing event '{e['title']}' with format '{datetime_format}': {ve}")
            raise

    filename = f"{team.replace(' ', '_')}.ics"
    filepath = os.path.join(output_dir, filename)

     # Add blank lines after header and between events
    lines = cal.serialize().splitlines()
    output_lines = []
    # Add blank line after header (after BEGIN:VCALENDAR)
    for line in lines:
        output_lines.append(line)
        if line.strip() == "BEGIN:VCALENDAR":
            output_lines.append("")  # Blank line after header
        elif line.strip() == "END:VEVENT":
            output_lines.append("")  # Blank line after each event

    with open(filepath, "w", encoding="utf-8") as f:
        f.write("\n".join(output_lines) + "\n")

    return filename

def create_ics(team, events, output_dir, datetime_format, timezone=None, branding=None):
    cal = Calendar()

    # Branding defaults
    branding = branding or {}
    cal_name = branding.get("name", team)
    cal_desc = branding.get("description", f"Calendar for {team}")
    cal_color = branding.get("color")  # Optional, not standard in ICS
    cal_footer = branding.get("footer", "")

    # Calendar metadata
    cal.extra.append(ContentLine(name="X-WR-CALNAME", value=cal_name))
    cal.extra.append(ContentLine(name="NAME", value=cal_name))
    cal.extra.append(ContentLine(name="X-WR-CALDESC", value=cal_desc))
    if cal_color:
        cal.extra.append(ContentLine(name="X-APPLE-CALENDAR-COLOR", value=cal_color))  # Apple-specific

    for e in events:
        try:
            event = Event()
            event.name = e["title"]
            dt_start = datetime.strptime(e["start"], datetime_format)
            dt_end = datetime.strptime(e["end"], datetime_format)

            # Apply timezone if provided
            if timezone:
                try:
                    import zoneinfo
                    tz = zoneinfo.ZoneInfo(timezone)
                    dt_start = dt_start.replace(tzinfo=tz)
                    dt_end = dt_end.replace(tzinfo=tz)
                except Exception as tz_err:
                    print(f"âš ï¸ Timezone error for '{team}': {tz_err}")

            event.begin = dt_start
            event.end = dt_end
            event.location = e["location"]
            event.description = e["description"]
            cal.events.add(event)
        except ValueError as ve:
            print(f"âŒ Error parsing event '{e['title']}' with format '{datetime_format}': {ve}")
            raise

    # Optional footer event
    if cal_footer:
        footer_event = Event()
        footer_event.name = "Calendar Footer"
        footer_event.description = cal_footer
        footer_event.begin = dt_end  # Place it after last event
        footer_event.duration = {"minutes": 1}
        cal.events.add(footer_event)

    filename = f"{team.replace(' ', '_')}.ics"
    filepath = os.path.join(output_dir, filename)

    # Add blank lines after header and between events
    lines = cal.serialize().splitlines()
    output_lines = []
    for line in lines:
        output_lines.append(line)
        if line.strip() == "BEGIN:VCALENDAR":
            output_lines.append("")
        elif line.strip() == "END:VEVENT":
            output_lines.append("")

    with open(filepath, "w", encoding="utf-8") as f:
        f.write("\n".join(output_lines) + "\n")

    return filename

def generate_download_page(file_list, output_dir):
    page_path = os.path.join(output_dir, "download_links.md")
    with open(page_path, "w", encoding="utf-8") as f:  # âœ… Add encoding
        f.write("# ðŸ—“ï¸ Team Calendar Downloads\n\n")
        for filename in file_list:
            team_name = filename.replace(".ics", "").replace("_", " ")
            f.write(f"- **{team_name}**: [Download {filename}](./{filename})\n")

# def process_csv(input_path, output_dir="calendars", datetime_format=None):
    # validate_csv_path(input_path)
    # ensure_output_dir(output_dir)

    # events_by_team, samples = read_events(input_path)

    # if not datetime_format:
        # datetime_format = detect_datetime_format(samples)
        # if not datetime_format:
            # raise ValueError("Unable to auto-detect datetime format.")

    # generated_files = []
    # for team, events in events_by_team.items():
        # filename = create_ics(team, events, output_dir, datetime_format)
        # generated_files.append(filename)

    # generate_download_page(generated_files, output_dir)
    # return {
        # "output_dir": output_dir,
        # "generated_files": generated_files,
        # "datetime_format": datetime_format
    # }

def process_csv(input_or_config, output_dir=None, datetime_format=None):
    # Determine mode: hosted (dict) or CLI (str)
    if isinstance(input_or_config, dict):
        # Hosted mode
        input_path = input_or_config.get("csv")
        output_dir = input_or_config.get("output", "calendars")
        datetime_format = input_or_config.get("datetime_format", datetime_format)
        timezone = input_or_config.get("timezone")
        branding = input_or_config.get("branding", {})
    else:
        # CLI mode
        input_path = input_or_config
        output_dir = output_dir or "calendars"
        timezone = None
        branding = {}

    validate_csv_path(input_path)
    ensure_output_dir(output_dir)

    events_by_team, samples = read_events(input_path)

    if not datetime_format:
        datetime_format = detect_datetime_format(samples)
        if not datetime_format:
            raise ValueError("Unable to auto-detect datetime format.")

    generated_files = []
    for team, events in events_by_team.items():
        filename = create_ics(
            team,
            events,
            output_dir,
            datetime_format,
            timezone=timezone,
            branding=branding
        )
        generated_files.append(filename)

    generate_download_page(generated_files, output_dir)
    return {
        "output_dir": output_dir,
        "generated_files": generated_files,
        "datetime_format": datetime_format
    }

def main():
    parser = argparse.ArgumentParser(
        description="ðŸ“… Generate ICS calendar files from a CSV with auto-detected or manual datetime format.",
        formatter_class=argparse.RawTextHelpFormatter
    )

    parser.add_argument(
        "--input", "-i",
        default="events.csv",
        help="Path to input CSV file (default: events.csv)"
    )
    parser.add_argument(
        "--output", "-o",
        default="calendars",
        help="Directory to save generated ICS files (default: calendars)"
    )
    parser.add_argument(
        "--datetime-format", "-f",
        help="Optional datetime format override (e.g. \"%m/%d/%Y %I:%M %p\")"
    )

    args = parser.parse_args()

    print(f"\nðŸ“ Input CSV: {args.input}")
    print(f"ðŸ“‚ Output Directory: {args.output}")
    if args.datetime_format:
        print(f"ðŸ•’ Manual Format: {args.datetime_format}")

    try:
        result = process_csv(
            input_path=args.input,
            output_dir=args.output,
            datetime_format=args.datetime_format
        )

        print(f"\nâœ… Generated {len(result['generated_files'])} ICS file(s):")
        for fname in result["generated_files"]:
            print(f"   - {fname}")
        print(f"\nðŸ“„ Download page saved to: {os.path.join(result['output_dir'], 'download_links.md')}")
        print(f"ðŸ•’ Datetime format used: {result['datetime_format']}")

    except Exception as e:
        print(f"\nâŒ Failed to generate calendars: [{type(e).__name__}] {e}")
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()
