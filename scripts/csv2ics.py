import csv
import os
import re
import argparse
import sys
from collections import defaultdict
from datetime import datetime
from ics import Calendar, Event

COMMON_FORMATS = [
    "%Y-%m-%d %H:%M",
    "%m/%d/%Y %H:%M",
    "%m/%d/%Y %I:%M %p",
    "%Y-%m-%d %I:%M %p",
    "%d-%m-%Y %H:%M",
    "%d/%m/%Y %H:%M",
]

def find_column(columns, patterns):
    for pattern in patterns:
        regex = re.compile(pattern, re.IGNORECASE)
        for col in columns:
            if regex.match(col.strip()):
                return col
    return None

def parse_datetime(row, columns):
    start_dt_col = find_column(columns, ["^Start Date[- ]?Time$", "^Start.*Date.*Time$"])
    end_dt_col = find_column(columns, ["^End Date[- ]?Time$", "^End.*Date.*Time$"])

    if start_dt_col and end_dt_col:
        start = row[start_dt_col]
        end = row[end_dt_col]
    else:
        date_col = find_column(columns, ["^Date$"])
        start_date_col = find_column(columns, ["^Start Date$", "^Date$"])
        start_time_col = find_column(columns, ["^Start Time$", "^Start.*Time$"])
        end_date_col = find_column(columns, ["^End Date$", "^Date$"])
        end_time_col = find_column(columns, ["^End Time$", "^End.*Time$"])

        start_date = row.get(start_date_col) or row.get(date_col)
        start_time = row.get(start_time_col, "00:00")
        end_date = row.get(end_date_col) or row.get(date_col)
        end_time = row.get(end_time_col, "01:00")

        start = f"{start_date} {start_time}"
        end = f"{end_date} {end_time}"

    return start.strip(), end.strip()

def detect_datetime_format(samples):
    for fmt in COMMON_FORMATS:
        try:
            for start, end in samples:
                datetime.strptime(start, fmt)
                datetime.strptime(end, fmt)
            return fmt
        except ValueError:
            continue
    return None

def read_events(csv_file):
    events_by_team = defaultdict(list)
    samples = []
    with open(csv_file, newline='', encoding="utf-8-sig") as f:
        reader = csv.DictReader(f)
        columns = reader.fieldnames

        team_col = find_column(columns, ["^Team$"])
        title_col = find_column(columns, ["^Event Title$", "^Title$"])
        desc_col = find_column(columns, ["^Description$"])
        location_col = find_column(columns, ["^Location$"])

        for i, row in enumerate(reader):
            team = row.get(team_col, "General")
            start, end = parse_datetime(row, columns)

            if i < 5:
                samples.append((start, end))

            title = row.get(title_col) or row.get(desc_col) or "Untitled Event"
            description = row.get(desc_col) or row.get(title_col) or ""

            event = {
                "title": title,
                "start": start,
                "end": end,
                "location": row.get(location_col, ""),
                "description": description
            }
            events_by_team[team].append(event)
    return events_by_team, samples

def create_ics(team, events, output_dir, datetime_format):
    cal = Calendar()
    cal.extra.append(f"X-WR-CALNAME:{team}")  # ✅ Add calendar title
    cal.extra.append(f"NAME:{team}")
    cal.extra.append("X-WR-CALDESC:Generated by Mark Hogan's Calendar Builder")
    
    for e in events:
        try:
            event = Event()
            event.name = e["title"]
            event.begin = datetime.strptime(e["start"], datetime_format)
            event.end = datetime.strptime(e["end"], datetime_format)
            event.location = e["location"]
            event.description = e["description"]
            cal.events.add(event)
        except ValueError as ve:
            print(f"❌ Error parsing event '{e['title']}' with format '{datetime_format}': {ve}")
            sys.exit(1)
    filename = f"{team.replace(' ', '_')}.ics"
    filepath = os.path.join(output_dir, filename)

    # Manually format ICS content with blank lines
    lines = cal.serialize().splitlines()
    output_lines = []

    # Add blank line after header (after BEGIN:VCALENDAR)
    for i, line in enumerate(lines):
        output_lines.append(line)
        if line.strip() == "BEGIN:VCALENDAR":
            output_lines.append("")  # Blank line after header
        elif line.strip() == "END:VEVENT":
            output_lines.append("")  # Blank line after each event

    with open(filepath, "w", encoding="utf-8") as f:
        f.write("\n".join(output_lines) + "\n")

    return filename
    
def generate_download_page(file_list, output_dir):
    page_path = os.path.join(output_dir, "download_links.md")
    with open(page_path, "w", encoding="utf-8") as f:  # ✅ Add encoding
        f.write("# 🗓️ Team Calendar Downloads\n\n")
        for filename in file_list:
            team_name = filename.replace(".ics", "").replace("_", " ")
            f.write(f"- **{team_name}**: [Download {filename}](./{filename})\n")

def main():
    parser = argparse.ArgumentParser(
        description="""
📅 ICS Calendar Generator with Auto-Detect

Reads a CSV file and generates .ics calendar files per team. Supports flexible
column detection and auto-detects datetime format unless specified.

Example usage:
  python generate_calendars.py --input my_events.csv --output team_calendars
  python generate_calendars.py --input my_events.csv --datetime-format "%m/%d/%Y %I:%M %p"
""",
        formatter_class=argparse.RawTextHelpFormatter
    )

    parser.add_argument("--input", "-i", default="events.csv", help="Path to input CSV file")
    parser.add_argument("--output", "-o", default="calendars", help="Directory to save ICS files")
    parser.add_argument("--datetime-format", "-f", help="Manual datetime format override")

    args = parser.parse_args()

    print("📁 Reading CSV:", args.input)
    print("📂 Output directory:", args.output)

    os.makedirs(args.output, exist_ok=True)
    events_by_team, samples = read_events(args.input)

    if args.datetime_format:
        datetime_format = args.datetime_format
        print("🕒 Using manual datetime format:", datetime_format)
    else:
        datetime_format = detect_datetime_format(samples)
        if not datetime_format:
            print("❌ Unable to auto-detect datetime format from sample rows.")
            for i, (start, end) in enumerate(samples, 1):
                print(f"   Sample {i}: '{start}' → '{end}'")
            sys.exit(1)
        print("🔍 Auto-detected datetime format:", datetime_format)

    generated_files = []
    for team, events in events_by_team.items():
        filename = create_ics(team, events, args.output, datetime_format)
        generated_files.append(filename)

    generate_download_page(generated_files, args.output)
    print(f"\n✅ ICS files and download links saved to '{args.output}'")

if __name__ == "__main__":
    main()
